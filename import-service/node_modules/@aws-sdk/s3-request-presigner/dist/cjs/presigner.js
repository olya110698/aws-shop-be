"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3RequestPresigner = void 0;
const middleware_sdk_s3_1 = require("@aws-sdk/middleware-sdk-s3");
const constants_1 = require("./constants");
class S3RequestPresigner {
    constructor(options) {
        const resolvedOptions = {
            // Allow `signingName` because we want to support usecase of supply client's resolved config
            // directly. Where service equals signingName.
            service: options.signingName || options.service || "s3",
            uriEscapePath: options.uriEscapePath || false,
            applyChecksum: options.applyChecksum || false,
            ...options,
        };
        this.signer = new middleware_sdk_s3_1.S3SignatureV4(resolvedOptions);
    }
    async presign(requestToSign, { unsignableHeaders = new Set(), unhoistableHeaders = new Set(), ...options } = {}) {
        unsignableHeaders.add("content-type");
        // S3 requires SSE headers to be signed in headers instead of query
        // See: https://github.com/aws/aws-sdk-js-v3/issues/1576
        Object.keys(requestToSign.headers)
            .map((header) => header.toLowerCase())
            .filter((header) => header.startsWith("x-amz-server-side-encryption"))
            .forEach((header) => {
            unhoistableHeaders.add(header);
        });
        requestToSign.headers[constants_1.SHA256_HEADER] = constants_1.UNSIGNED_PAYLOAD;
        if (!requestToSign.headers["host"]) {
            requestToSign.headers.host = requestToSign.hostname;
            if (requestToSign.port) {
                requestToSign.headers.host = `${requestToSign.headers.host}:${requestToSign.port}`;
            }
        }
        return this.signer.presign(requestToSign, {
            expiresIn: 900,
            unsignableHeaders,
            unhoistableHeaders,
            ...options,
        });
    }
}
exports.S3RequestPresigner = S3RequestPresigner;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlc2lnbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ByZXNpZ25lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxrRUFBMkU7QUFJM0UsMkNBQThEO0FBUTlELE1BQWEsa0JBQWtCO0lBRTdCLFlBQVksT0FBa0M7UUFDNUMsTUFBTSxlQUFlLEdBQUc7WUFDdEIsNEZBQTRGO1lBQzVGLDhDQUE4QztZQUM5QyxPQUFPLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUk7WUFDdkQsYUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhLElBQUksS0FBSztZQUM3QyxhQUFhLEVBQUUsT0FBTyxDQUFDLGFBQWEsSUFBSSxLQUFLO1lBQzdDLEdBQUcsT0FBTztTQUNYLENBQUM7UUFDRixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksaUNBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU8sQ0FDbEIsYUFBMkIsRUFDM0IsRUFBRSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsRUFBRSxFQUFFLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLEVBQUUsR0FBRyxPQUFPLEtBQWlDLEVBQUU7UUFFOUcsaUJBQWlCLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3RDLG1FQUFtRTtRQUNuRSx3REFBd0Q7UUFDeEQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDO2FBQy9CLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3JDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO2FBQ3JFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2xCLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztRQUNMLGFBQWEsQ0FBQyxPQUFPLENBQUMseUJBQWEsQ0FBQyxHQUFHLDRCQUFnQixDQUFDO1FBQ3hELElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2xDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDcEQsSUFBSSxhQUFhLENBQUMsSUFBSSxFQUFFO2dCQUN0QixhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUNwRjtTQUNGO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7WUFDeEMsU0FBUyxFQUFFLEdBQUc7WUFDZCxpQkFBaUI7WUFDakIsa0JBQWtCO1lBQ2xCLEdBQUcsT0FBTztTQUNYLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQXpDRCxnREF5Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTM1NpZ25hdHVyZVY0LCBTM1NpZ25lclY0SW5pdCB9IGZyb20gXCJAYXdzLXNkay9taWRkbGV3YXJlLXNkay1zM1wiO1xuaW1wb3J0IHsgUmVxdWVzdFByZXNpZ25lciwgUmVxdWVzdFByZXNpZ25pbmdBcmd1bWVudHMgfSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcbmltcG9ydCB7IEh0dHBSZXF1ZXN0IGFzIElIdHRwUmVxdWVzdCB9IGZyb20gXCJAYXdzLXNkay90eXBlc1wiO1xuXG5pbXBvcnQgeyBTSEEyNTZfSEVBREVSLCBVTlNJR05FRF9QQVlMT0FEIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbnR5cGUgUGFydGlhbEJ5PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiBQYXJ0aWFsPFBpY2s8VCwgSz4+O1xuXG5leHBvcnQgdHlwZSBTM1JlcXVlc3RQcmVzaWduZXJPcHRpb25zID0gUGFydGlhbEJ5PFMzU2lnbmVyVjRJbml0LCBcInNlcnZpY2VcIiB8IFwidXJpRXNjYXBlUGF0aFwiPiAmIHtcbiAgc2lnbmluZ05hbWU/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY2xhc3MgUzNSZXF1ZXN0UHJlc2lnbmVyIGltcGxlbWVudHMgUmVxdWVzdFByZXNpZ25lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2lnbmVyOiBTM1NpZ25hdHVyZVY0O1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTM1JlcXVlc3RQcmVzaWduZXJPcHRpb25zKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgLy8gQWxsb3cgYHNpZ25pbmdOYW1lYCBiZWNhdXNlIHdlIHdhbnQgdG8gc3VwcG9ydCB1c2VjYXNlIG9mIHN1cHBseSBjbGllbnQncyByZXNvbHZlZCBjb25maWdcbiAgICAgIC8vIGRpcmVjdGx5LiBXaGVyZSBzZXJ2aWNlIGVxdWFscyBzaWduaW5nTmFtZS5cbiAgICAgIHNlcnZpY2U6IG9wdGlvbnMuc2lnbmluZ05hbWUgfHwgb3B0aW9ucy5zZXJ2aWNlIHx8IFwiczNcIixcbiAgICAgIHVyaUVzY2FwZVBhdGg6IG9wdGlvbnMudXJpRXNjYXBlUGF0aCB8fCBmYWxzZSxcbiAgICAgIGFwcGx5Q2hlY2tzdW06IG9wdGlvbnMuYXBwbHlDaGVja3N1bSB8fCBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICB0aGlzLnNpZ25lciA9IG5ldyBTM1NpZ25hdHVyZVY0KHJlc29sdmVkT3B0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcHJlc2lnbihcbiAgICByZXF1ZXN0VG9TaWduOiBJSHR0cFJlcXVlc3QsXG4gICAgeyB1bnNpZ25hYmxlSGVhZGVycyA9IG5ldyBTZXQoKSwgdW5ob2lzdGFibGVIZWFkZXJzID0gbmV3IFNldCgpLCAuLi5vcHRpb25zIH06IFJlcXVlc3RQcmVzaWduaW5nQXJndW1lbnRzID0ge31cbiAgKTogUHJvbWlzZTxJSHR0cFJlcXVlc3Q+IHtcbiAgICB1bnNpZ25hYmxlSGVhZGVycy5hZGQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgLy8gUzMgcmVxdWlyZXMgU1NFIGhlYWRlcnMgdG8gYmUgc2lnbmVkIGluIGhlYWRlcnMgaW5zdGVhZCBvZiBxdWVyeVxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzLXYzL2lzc3Vlcy8xNTc2XG4gICAgT2JqZWN0LmtleXMocmVxdWVzdFRvU2lnbi5oZWFkZXJzKVxuICAgICAgLm1hcCgoaGVhZGVyKSA9PiBoZWFkZXIudG9Mb3dlckNhc2UoKSlcbiAgICAgIC5maWx0ZXIoKGhlYWRlcikgPT4gaGVhZGVyLnN0YXJ0c1dpdGgoXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCIpKVxuICAgICAgLmZvckVhY2goKGhlYWRlcikgPT4ge1xuICAgICAgICB1bmhvaXN0YWJsZUhlYWRlcnMuYWRkKGhlYWRlcik7XG4gICAgICB9KTtcbiAgICByZXF1ZXN0VG9TaWduLmhlYWRlcnNbU0hBMjU2X0hFQURFUl0gPSBVTlNJR05FRF9QQVlMT0FEO1xuICAgIGlmICghcmVxdWVzdFRvU2lnbi5oZWFkZXJzW1wiaG9zdFwiXSkge1xuICAgICAgcmVxdWVzdFRvU2lnbi5oZWFkZXJzLmhvc3QgPSByZXF1ZXN0VG9TaWduLmhvc3RuYW1lO1xuICAgICAgaWYgKHJlcXVlc3RUb1NpZ24ucG9ydCkge1xuICAgICAgICByZXF1ZXN0VG9TaWduLmhlYWRlcnMuaG9zdCA9IGAke3JlcXVlc3RUb1NpZ24uaGVhZGVycy5ob3N0fToke3JlcXVlc3RUb1NpZ24ucG9ydH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduZXIucHJlc2lnbihyZXF1ZXN0VG9TaWduLCB7XG4gICAgICBleHBpcmVzSW46IDkwMCxcbiAgICAgIHVuc2lnbmFibGVIZWFkZXJzLFxuICAgICAgdW5ob2lzdGFibGVIZWFkZXJzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuIl19